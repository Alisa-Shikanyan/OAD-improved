# -*- coding: utf-8 -*-
"""
Created on Fri Feb 11 11:37:29 2022

@author: Student
"""

#теперь походу про МНК........((
#но это тоже нужно в домашке))
#чето формула мнк x = (A^T*A)^-1 * A^T * b
#свд разложение A = UEV^T (U, V ортогональны, E типа диагональная с сингулярными числами?)
#корректная задача = решение есть, единственно (?), устойчиво(малые изменения задачи=малое изменение решения)
# число обсуловленности (отношение макс синг числа к мин) - показывает насколько матрица близка к вырожденной (если большое-близка к вырожд) и обратная матрица - проблема

# запрогаем решение мнк через свд)))))
import numpy as np
import matplotlib.pyplot as plt
def lstsq_svd(a, b, rcond=None): #функция нужная для домашки ровно та
    a = np.atleast_2d(a)
    b = np.atleast_1d(b)
    u, s, vh = np.linalg.svd(a, full_matrices=False)
    if rcond is None: #тут что-то про обработку некорректных задач??
        where = (s!=0)
    else:
        where = s > s[0] * rcond
    x = vh.T @ np.divide(u.T[:s.shape[0], :] @ b, s, out=np.zeros(a.shape[1]), where=where) #чето умножаем, делим; divide функция которая делит при каком-то условии (здесь - что синг числа не ноль)
    #реализуем отклонение между экспериментом и значением
    r = a @ x - b #b это реальность, a@х то что пофитили
    cost = np.inner(r, r)
    sigma = cost / (b.shape[0] - x.shape[0])
    var = vh.T @ np.diag(s**(-2)) @ vh * sigma #матрица ошибок коэффициентов W (просто формула для нее такая)
    
    return x, cost, var

#3 функцияв домашке это как бы комбинация 1 и 2 - иногда вызывает первую иногда вторую (2=наша свд написанная)
# степень свободы = (количество экспериментов - количество параметров)
    
#в третьей части с 4д массивом размер должен быть (100, 2, 659, 493) - 1/2 и 3/4 мб поменяны местами но да
#где-то там вычесть что-то отпервой пары я не помню где-то в конце про фотоны

#чето еще для домашки но щас напишем с другими размерами
X_test = np.random.normal(size=(15,))
A_test = np.random.normal(size=(500, 15))

from scipy.stats import norm
#проверяем не хи квадрат а нормальное распределние
noise_level = 0.1 #амплитуда шума?
noise = np.random.normal(size=(1000, 500)) #сгенерим 1000 реализаций
X = np.asarray([lstsq_svd(A_test, A_test @ X_test + noise_level * n)[0] for n in noise])
